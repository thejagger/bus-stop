---
alwaysApply: true
---

# Cursor AI Development Rules for HPCNGS

> **This is the single source of truth** for all development patterns, tools, and best practices in this project.

---

## üì¶ Tech Stack

### Core Framework
- **React 19** - Latest React with concurrent features
- **TypeScript 5.9** - Type-safe development
- **Vite (Rolldown)** - Ultra-fast build tool
- **React Router DOM 7** - Client-side routing

### State & Data Management
- **TanStack Query v5** - Server state management, caching, data fetching
- **Zustand** - Client state management (lightweight)
- **React Hook Form** - Form state management
- **Zod v4** - Schema validation and type inference

### Backend & Database
- **Supabase** - PostgreSQL database, authentication, real-time subscriptions
- **@supabase/supabase-js v2** - Supabase client library

### UI & Styling
- **Tailwind CSS v4** - Utility-first CSS framework
- **Shadcn UI** - Component library built on Radix UI
- **Radix UI** - Headless, accessible UI primitives
- **Lucide React** - Icon library (primary)
- **Tabler Icons** - Additional icon library (secondary)

### Additional Libraries
- **date-fns** - Date manipulation library
- **react-day-picker** - Date picker component
- **sonner** - Toast notifications
- **vaul** - Drawer component
- **next-themes** - Theme management (dark/light mode)
- **clsx + tailwind-merge** - Conditional class names

---

## üéØ Core Principles

### 1. **Reusability First**

- Always think: "Can this be used elsewhere?"
- Never create inline, one-off solutions
- Build components that can be reused multiple times
- Add new features to FormBuilder or DataTable as reusable addons

### 2. **Schema-First Development**

- All data models MUST use Zod schemas
- All forms MUST use FormBuilder with schemas
- All tables MUST use DataTableSupabase with proper column definitions
- Never bypass validation

### 3. **Type Safety**

- Full TypeScript usage - no `any` types without justification
- Leverage Zod type inference: `z.infer<typeof Schema>`
- Use proper TypeScript generics for reusable components

---

## üèóÔ∏è Architecture Patterns

### BaseModel System

- **Extend BaseModel** for all data operations (see `src/lib/base.model.ts`)
- Define Zod schema first
- Configure relations properly (1:1, 1:n, n:m)
- Use soft deletes (`is_deleted` flag)
- Leverage `getAllQuery()` for custom filtering

#### Creating a Model

```typescript
// 1. Define Zod Schema
export const CustomerSchema = z.object({
  id: z.number().nullish(),
  customer_name: z.string(),
  email: z.string().email(),
  is_active: z.boolean().default(true),
  created_at: z.iso.datetime({offset: true}).nullish(),
  // Nested relation
  sites: z.array(CustomerSiteSchema.partial()).nullish(),
});

export type Customer = z.infer<typeof CustomerSchema>;

// 2. Create Model Class
export class CustomerModel extends BaseModel<typeof CustomerSchema> {
  constructor(id?: string | number) {
    const relations: Relation<typeof CustomerSiteSchema>[] = [
      {
        key: "sites",                    // Property name in schema
        nestedModel: new CustomerSiteModel(), // Nested model instance
        isArray: true,                   // 1:n relationship
        exclude: false,                  // Include in upsert
        foreignKey: "customer_id",       // Foreign key in sites table
      },
    ];

    super(
      supabase,              // Supabase client instance
      "customer",            // Database table name
      "/customer",           // Base URL path
      CustomerSchema,        // Zod schema
      id,                    // Optional ID for single record
      relations              // Relations array
    );
  }
}
```

#### BaseModel API

**Query Methods:**
```typescript
// Get all records
const { data, count } = await model.getAll("*");

// Get query builder (for custom queries)
const query = model.getAllQuery("*");
query.eq("is_active", true).order("created_at", { ascending: false });

// Load single record by ID
const model = new CustomerModel(customerId);
const data = await model.loadData("*");
```

**Mutation Methods:**
```typescript
// Create or update (upsert)
const result = await model.upsert({
  customer_name: "ACME Corp",
  email: "info@acme.com",
  sites: [{ address: "123 Main St", city: "Vienna" }]
});

// Soft delete
await model.delete(customerId);
```

**Relation Configuration:**
```typescript
type Relation<K extends z.ZodType> = {
  key: string;              // Property name in parent schema
  nestedModel: BaseModel<K>; // Instance of nested model
  isArray?: boolean;        // true for 1:n, false for 1:1
  exclude?: boolean;        // true to exclude from upsert
  foreignKey: string;       // Column in nested table linking to parent
};
```

### FormBuilder System

- **Use FormBuilder** for ALL forms (see `src/components/formbuilder/`)
- **File Structure**:
  - Default fields: `form-builder-fields-default.tsx` (FBInput, FBTextArea, FBSelect, FBCombobox, FBCheckbox, FBRadio, FBSwitch, FBDatePicker, FBHiddenInput)
  - Action fields: `form-builder-fields-action.tsx` (FBSubmit, FBCancel)
  - File fields: `form-builder-fields-file.tsx` (FBAvatarUpload)
- When creating new field types, add to the appropriate file as reusable components
- Follow the Controller + Field pattern for custom fields

#### Basic Usage

```typescript
import { FormBuilder, FBForm } from "@/components/formbuilder/form-builder";
import { FBInput } from "@/components/formbuilder/form-builder-fields-default";
import { FBSubmit, FBCancel } from "@/components/formbuilder/form-builder-fields-action";

<FormBuilder schema={Schema} values={data}>
  <FBForm onSubmit={handleSubmit}>
    <FBInput name="field_name" label="Label" />
    <div className="flex gap-2">
      <FBSubmit handleSubmit={handleSubmit} />
      <FBCancel to="/back-path" />
    </div>
  </FBForm>
</FormBuilder>
```

#### Available Field Components

**FBInput** - Text input field
```typescript
<FBInput 
  name="customer_name"          // Required
  label="Customer Name"         // Required
  type="text"                   // Optional: text, email, number, password, tel, url, search (default: "text")
  placeholder="Enter name"      // Optional (defaults to label)
  disabled={false}              // Optional
/>
```

**FBTextArea** - Multi-line text input
```typescript
<FBTextArea 
  name="description" 
  label="Description"
  placeholder="Enter description"            // Optional (defaults to label)
  description="Provide detailed information"  // Optional: help text
/>
```

**FBSelect** - Dropdown select
```typescript
<FBSelect 
  name="country"
  label="Country"
  placeholder="Select country"              // Optional (defaults to label)
  description="Choose your country"        // Optional
  disabled={false}                         // Optional
  options={[                               // Required
    { label: "Austria", value: "AT" },
    { label: "Germany", value: "DE" },
  ]}
/>
```

**FBCombobox** - Searchable select (command palette style)
```typescript
<FBCombobox 
  name="customer_id"
  label="Customer"
  placeholder="Select customer"            // Optional
  description="Search for a customer"     // Optional
  disabled={false}                         // Optional
  modal={true}                             // Optional: open as modal (default: false)
  options={[                                // Required: values must be strings
    { label: "ACME Corp", value: "1" },
    { label: "TechCo", value: "2" },
  ]}
/>
```

**FBCheckbox** - Single checkbox
```typescript
<FBCheckbox 
  name="is_active"
  label="Active"
  legend="Account Status"         // Optional: fieldset legend
  description="Enable this account"  // Optional
/>
```

**FBRadio** - Radio button group
```typescript
<FBRadio 
  name="account_type"
  label="Account Type"
  description="Select account type"      // Optional
  options={[                             // Required
    { label: "Personal", value: "personal" },
    { label: "Business", value: "business" },
  ]}
/>
```

**FBSwitch** - Toggle switch
```typescript
<FBSwitch 
  name="notifications_enabled"
  label="Enable Notifications"
  description="Receive email notifications"  // Optional
/>
```

**FBDatePicker** - Date picker with calendar popup
```typescript
<FBDatePicker 
  name="birth_date"
  label="Birth Date"
  placeholder="Select date"              // Optional (defaults to label)
/>
// Stores as "yyyy-MM-dd" string
```

**FBHiddenInput** - Hidden input field
```typescript
<FBHiddenInput name="customer_id" value={customerId} />
```

**FBAvatarUpload** - Avatar/image upload with Supabase Storage
```typescript
<FBAvatarUpload 
  name="avatar_url"                    // Required
  label="Profile Picture"              // Required
  description="Upload an avatar"      // Optional
  bucketName="storage"                // Required: Supabase bucket name
  folder="avatars"                    // Required: folder within bucket
  maxSize={2 * 1024 * 1024}          // Optional: max size in bytes (default: 2MB)
  disabled={false}                    // Optional
  generateFileName={(file, fieldName) => string}  // Optional: custom file name generator
  deleteOldFile={true}                // Optional: delete old file when replacing (default: true)
/>
// Schema: Use z.string().url().nullish() for the field
```

**FBSubmit** - Submit button
```typescript
<FBSubmit 
  label="Save Customer"           // Optional: button text (default: translated "Submit")
  handleSubmit={handleSubmit}     // Required: function that receives validated form data
/>
```

**FBCancel** - Cancel button
```typescript
<FBCancel 
  label="Cancel"                  // Optional: button text (default: translated "Cancel")
  to="/customers"                 // Required: route path (string) or route object
/>
```

### DataTable System

- **Use DataTableSupabase** for ALL tables (see `src/components/data-table/`)
- Define columns with proper configuration
- Use `callback` for custom cell rendering
- Use `accessorFn` for computed values
- Add custom filters to `custom-filter-fn.tsx` as reusable functions
- Leverage default actions (edit, copy, delete) when appropriate

#### Basic Usage

```typescript
const columns: SupabaseDataTableColumn[] = [
  {
    key: "name",
    title: "Name",
    isSortable: true,
    isGlobalFilterable: true,
  },
  {
    key: "actions",
    isAction: true,
    useDefaultActions: true,
  },
];

<DataTableSupabase
  columns={columns}
  queryFn={() => model.getAllQuery()}
  baseModel={model}
/>
```

#### Column Examples

**Simple Text Column:**
```typescript
{
  key: "customer_name",
  title: "Customer Name",
  isSortable: true,
  isHideable: true,
  isGlobalFilterable: true,
}
```

**Custom Cell Renderer:**
```typescript
{
  key: "email",
  title: "Email",
  callback: (props) => (
    <a href={`mailto:${props.getValue()}`} className="text-blue-600 hover:underline">
      {props.getValue()}
    </a>
  ),
  isGlobalFilterable: true,
}
```

**Custom Accessor (Computed Value):**
```typescript
{
  key: "full_name",
  title: "Full Name",
  accessorFn: (row) => `${row.first_name} ${row.last_name}`,
  isSortable: true,
  isGlobalFilterable: true,
}
```

**Boolean Column with Filter:**
```typescript
{
  key: "is_active",
  title: "Status",
  callback: (props) => (
    <Badge variant={props.getValue() ? "success" : "secondary"}>
      {props.getValue() ? "Active" : "Inactive"}
    </Badge>
  ),
  filter: {
    type: "radio",
    options: [
      { label: "Active", value: "true" },
      { label: "Inactive", value: "false" },
    ],
  },
}
```

**Date Column:**
```typescript
{
  key: "created_at",
  title: "Created",
  callback: (props) => format(new Date(props.getValue()), "PPP"),
  isSortable: true,
}
```

**Relation Column:**
```typescript
{
  key: "customer.customer_name",
  title: "Customer",
  accessorFn: (row) => row.customer?.customer_name,
  isSortable: true,
  isGlobalFilterable: true,
}
```

**Custom Actions:**
```typescript
{
  key: "actions",
  isAction: true,
  useDefaultActions: false,
  actionCallback: (row) => [
    <DropdownMenuItem onClick={() => handleApprove(row.original.id)}>
      <Check className="mr-2 h-4 w-4" />
      Approve
    </DropdownMenuItem>,
    <DefaultDeleteAction baseModel={model} rowId={row.original.id} />,
  ],
}
```

---

## üé® Component Guidelines

### Shadcn Components

**üö® CRITICAL RULES:**

1. **ALWAYS use the Shadcn MCP Server** when implementing Shadcn components

   - Run: `mcp_shadcn_getComponent` to get component documentation
   - Run: `mcp_shadcn_getComponents` to list available components

2. **ALWAYS search Brave** for the latest Shadcn documentation before implementing

   - Search: `"shadcn ui [component-name] latest version documentation"`
   - Verify API changes and best practices

3. **NEVER assume** component APIs are the same as previous versions

   - Components change frequently
   - Always verify before using

4. **Available Components** (in `src/components/ui/`):

   - alert-dialog, avatar, badge, breadcrumb, button, calendar, card, chart
   - checkbox, collapsible, command, dialog, drawer, dropdown-menu
   - field, form, input, label, popover, radio-group, select, separator
   - sheet, sidebar, skeleton, sonner, spinner, switch, table, tabs
   - textarea, toggle, tooltip

5. **Installing New Components**:
   ```bash
   npx shadcn@latest add [component-name]
   ```
   - Check MCP first
   - Check Brave search second
   - Then install

### Icon Libraries

- **Primary**: Lucide React (`import { IconName } from "lucide-react"`)
- **Secondary**: Tabler Icons (only if icon not in Lucide)

---

## üìÅ Feature Module Structure

Every new feature MUST follow this structure:

```
src/app/[feature-name]/
‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îî‚îÄ‚îÄ [feature-name].model.ts    # Schema + Model class
‚îú‚îÄ‚îÄ ui/                             # Feature-specific components
‚îÇ   ‚îú‚îÄ‚îÄ [feature-name]_form.tsx
‚îÇ   ‚îî‚îÄ‚îÄ [feature-name]_list.tsx
‚îú‚îÄ‚îÄ page.tsx                        # List view (DataTable)
‚îî‚îÄ‚îÄ detail.tsx                      # Create/Edit view (FormBuilder)
```

---

## üîß Development Workflow

### Creating New Features

1. **Create Zod Schema** in `model/[name].model.ts`
2. **Create Model Class** extending BaseModel
3. **Create Page (List View)** with DataTableSupabase
4. **Create Detail (Form View)** with FormBuilder
5. **Format files** using `mcp_jetbrains_reformat_file`
6. **Check for errors** using `mcp_jetbrains_get_file_problems`
7. **Fix any errors** found
8. **Add Routes** to router configuration
9. **Add Navigation** to `src/config/navigation.ts`

### Implementing Relations

1. Define nested schema and model
2. Update parent schema with relation field
3. Configure relations in parent model constructor
4. Create nested UI component (form or table)
5. Include in parent detail page
6. **Format all modified files** using IntelliJ MCP
7. **Check for errors** using IntelliJ MCP

---

## üíæ Database & Supabase

### Conventions

- **Tables**: Singular, lowercase with underscores (`customer`, `customer_site`)
- **Columns**: Lowercase with underscores (`customer_name`, `is_active`)
- **Foreign Keys**: `{table}_id` (e.g., `customer_id`)
- **Required Columns**: `id`, `is_active`, `is_deleted`, `created_at`, `modified_at`

### Best Practices

- ALWAYS filter `is_deleted = false` in queries
- Use RLS (Row Level Security) for all tables
- Use BaseModel methods instead of raw Supabase queries
- Handle errors gracefully with try-catch
- Use TanStack Query for data fetching

---

## üåç Internationalization

- Use `useTranslation()` from `react-i18next`
- Translation files in `src/locales/[lang]/[namespace].json`
- Always provide translations for user-facing text

```typescript
const { t } = useTranslation("namespace");
return <Button>{t("key")}</Button>;
```

---

## ‚úÖ Code Quality Rules

### Always Do:

- ‚úÖ Use `useMemo()` for model instances
- ‚úÖ Use `useQuery()` for data fetching
- ‚úÖ Use `useMutation()` for data mutations
- ‚úÖ Handle loading, error, and empty states
- ‚úÖ Use `toast` from `sonner` for user feedback
- ‚úÖ Validate with Zod schemas
- ‚úÖ Use TypeScript strictly
- ‚úÖ Follow existing patterns in codebase
- ‚úÖ Make components reusable
- ‚úÖ Add proper error handling
- ‚úÖ Use semantic HTML
- ‚úÖ Ensure accessibility (aria labels, keyboard navigation)

### Never Do:

- ‚ùå Bypass schema validation
- ‚ùå Use inline forms (always use FormBuilder)
- ‚ùå Use inline tables (always use DataTableSupabase)
- ‚ùå Create non-reusable components
- ‚ùå Hardcode values that should be configuration
- ‚ùå Use `any` type without justification
- ‚ùå Ignore errors or loading states
- ‚ùå Create duplicate logic
- ‚ùå Forget to handle edge cases
- ‚ùå Skip internationalization

---

## üîß IntelliJ MCP Server Integration

**üö® CRITICAL: Always use IntelliJ MCP Server for IDE operations**

This project uses IntelliJ IDEA as the primary IDE, and all IDE-related operations MUST use the IntelliJ MCP Server to ensure consistency with IntelliJ's formatting, error checking, and project structure.

### Formatting

**ALWAYS use IntelliJ formatting instead of VSCode formatting:**

- **After editing any file**, use `mcp_jetbrains_reformat_file` to apply IntelliJ's code formatting
- This ensures code matches the project's IntelliJ formatting configuration
- Format files immediately after making changes, before checking for errors

```typescript
// Pattern: After editing a file, always reformat it
// Use: mcp_jetbrains_reformat_file with pathInProject relative to project root
```

### Error Checking & TypeScript Validation

**ALWAYS use IntelliJ's error checking:**

- Use `mcp_jetbrains_get_file_problems` to check for TypeScript errors, warnings, and code issues
- Check files after editing to catch errors early
- Use `errorsOnly: false` to see both errors and warnings
- IntelliJ's inspections provide more comprehensive error detection than basic TypeScript checking

```typescript
// Pattern: Check for errors after editing
// Use: mcp_jetbrains_get_file_problems with pathInProject
// Returns: List of problems with severity, description, and location
```

### File Operations

**Use IntelliJ MCP tools for file operations:**

- **Reading files**: Use `mcp_jetbrains_get_file_text_by_path` when you need file content
- **Editing files**: Use `mcp_jetbrains_replace_text_in_file` for text replacements (respects IntelliJ's formatting)
- **Creating files**: Use `mcp_jetbrains_create_new_file` to create new files
- **Finding files**: Use `mcp_jetbrains_find_files_by_name_keyword` or `mcp_jetbrains_find_files_by_glob` for file searches

### Symbol Information

**Use IntelliJ's symbol resolution:**

- Use `mcp_jetbrains_get_symbol_info` to get detailed information about symbols (functions, classes, variables)
- Provides declaration location, type information, and documentation
- More accurate than basic text search

### Project Information

**Use IntelliJ MCP for project structure:**

- Use `mcp_jetbrains_get_project_modules` to understand project structure
- Use `mcp_jetbrains_get_project_dependencies` to check dependencies
- Use `mcp_jetbrains_list_directory_tree` to explore directories
- Use `mcp_jetbrains_get_all_open_file_paths` to see currently open files

### Search Operations

**Use IntelliJ's search capabilities:**

- Use `mcp_jetbrains_search_in_files_by_text` for text search across the project
- Use `mcp_jetbrains_search_in_files_by_regex` for regex-based searches
- Faster and more accurate than basic grep operations

### Refactoring

**Use IntelliJ's refactoring tools:**

- Use `mcp_jetbrains_rename_refactoring` for renaming symbols (updates all references automatically)
- More reliable than manual search-and-replace

### Workflow Pattern

**Standard workflow when editing files:**

1. **Read/Edit file** using IntelliJ MCP tools
2. **Make changes** using `mcp_jetbrains_replace_text_in_file` or `mcp_jetbrains_create_new_file`
3. **Reformat file** using `mcp_jetbrains_reformat_file` (applies IntelliJ formatting)
4. **Check for errors** using `mcp_jetbrains_get_file_problems`
5. **Fix any errors** found
6. **Repeat steps 3-5** until no errors remain

### Important Notes

- **Always provide `projectPath`** parameter when available (use workspace root: `C:\work\hpcngs-new`)
- **Use relative paths** for `pathInProject` (relative to project root)
- **IntelliJ formatting takes precedence** - never use VSCode formatting tools
- **IntelliJ error checking is authoritative** - use it instead of basic TypeScript checking
- **File paths are case-sensitive** - use exact paths as they appear in the project

### Available IntelliJ MCP Tools

- `mcp_jetbrains_reformat_file` - Format code using IntelliJ settings
- `mcp_jetbrains_get_file_problems` - Check for errors and warnings
- `mcp_jetbrains_get_symbol_info` - Get symbol information
- `mcp_jetbrains_replace_text_in_file` - Replace text in files
- `mcp_jetbrains_create_new_file` - Create new files
- `mcp_jetbrains_get_file_text_by_path` - Read file contents
- `mcp_jetbrains_find_files_by_name_keyword` - Find files by name
- `mcp_jetbrains_find_files_by_glob` - Find files by glob pattern
- `mcp_jetbrains_search_in_files_by_text` - Search for text in files
- `mcp_jetbrains_search_in_files_by_regex` - Search with regex
- `mcp_jetbrains_rename_refactoring` - Rename symbols safely
- `mcp_jetbrains_get_project_modules` - Get project modules
- `mcp_jetbrains_get_project_dependencies` - Get dependencies
- `mcp_jetbrains_list_directory_tree` - List directory structure
- `mcp_jetbrains_get_all_open_file_paths` - Get open files
- `mcp_jetbrains_open_file_in_editor` - Open file in IntelliJ
- `mcp_jetbrains_execute_terminal_command` - Execute terminal commands

---

## üéØ Reusability Checklist

Before creating any component, ask:

1. **Can this be used in multiple places?** ‚Üí Make it generic
2. **Does it fit into FormBuilder?** ‚Üí Add as `FBComponent`
3. **Does it fit into DataTable?** ‚Üí Add as column callback or filter
4. **Is this a common UI pattern?** ‚Üí Create in `src/components/`
5. **Is this domain-specific?** ‚Üí Create in feature's `ui/` folder

---

## üöÄ Performance & Best Practices

- Use `useMemo()` and `useCallback()` appropriately
- Implement proper pagination for large datasets
- Use React Query's caching and invalidation
- Optimize Supabase queries (select only needed columns)
- Use proper indexes on database tables
- Implement skeleton loading states
- Use proper error boundaries

---

## üìñ Quick Reference

### Common Imports

```typescript
// React
import { useState, useEffect, useMemo, useCallback } from "react";

// Router
import { useParams, useNavigate, Link } from "react-router-dom";

// Query
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

// Forms
import { useFormContext, Controller } from "react-hook-form";

// Validation
import { z } from "zod";

// UI
import { Button } from "@/components/ui/button";
import { toast } from "sonner";

// Base
import { BaseModel } from "@/lib/base.model";
import { supabase } from "@/lib/supabase-client";

// FormBuilder
import { FormBuilder, FBForm } from "@/components/formbuilder/form-builder";
import { 
  FBInput, 
  FBTextArea, 
  FBSelect, 
  FBCombobox, 
  FBCheckbox, 
  FBRadio, 
  FBSwitch, 
  FBDatePicker, 
  FBHiddenInput 
} from "@/components/formbuilder/form-builder-fields-default";
import { FBSubmit, FBCancel } from "@/components/formbuilder/form-builder-fields-action";
import { FBAvatarUpload } from "@/components/formbuilder/form-builder-fields-file";

// DataTable
import {
  DataTableSupabase,
  type SupabaseDataTableColumn,
} from "@/components/data-table/data-table-supabase";
```

### File Templates

#### Model Template

```typescript
import { z } from "zod";
import { BaseModel, type Relation } from "@/lib/base.model";
import { supabase } from "@/lib/supabase-client";

export const [Name]Schema = z.object({
  id: z.number().nullish(),
  // Your fields here
  is_active: z.boolean().default(true),
  created_at: z.iso.datetime({ offset: true }).nullish(),
  modified_at: z.iso.datetime({ offset: true }).nullish(),
});

export type [Name] = z.infer<typeof [Name]Schema>;

export class [Name]Model extends BaseModel<typeof [Name]Schema> {
  constructor(id?: string | number) {
    const relations: Relation<any>[] = [];
    
    super(
      supabase,
      "[table_name]",
      "/[path]",
      [Name]Schema,
      id,
      relations
    );
  }
}
```

#### Page Template (List View)

```typescript
import { useMemo } from "react";
import { DataTableSupabase, type SupabaseDataTableColumn } from "@/components/data-table/data-table-supabase";
import { [Name]Model } from "./model/[name].model";

export default function [Name]Page() {
  const model = useMemo(() => new [Name]Model(), []);

  const columns: SupabaseDataTableColumn[] = [
    {
      key: "name",
      title: "Name",
      isSortable: true,
      isGlobalFilterable: true,
    },
    {
      key: "actions",
      isAction: true,
      useDefaultActions: true,
    },
  ];

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">[Name]s</h1>
      <DataTableSupabase
        columns={columns}
        queryFn={() => model.getAllQuery()}
        baseModel={model}
      />
    </div>
  );
}
```

#### Detail Template (Form View)

```typescript
import { useMemo } from "react";
import { useParams } from "react-router-dom";
import { useQuery, useMutation } from "@tanstack/react-query";
import { toast } from "sonner";
import { FormBuilder, FBForm } from "@/components/formbuilder/form-builder";
import { FBInput } from "@/components/formbuilder/form-builder-fields-default";
import { FBSubmit, FBCancel } from "@/components/formbuilder/form-builder-fields-action";
import { [Name]Model, [Name]Schema } from "./model/[name].model";
import type { z } from "zod";

export default function [Name]Detail() {
  const { id } = useParams();
  const model = useMemo(() => new [Name]Model(id), [id]);

  const { data, isLoading } = useQuery({
    queryKey: ["[name]", id],
    queryFn: () => model.loadData(),
    enabled: id !== "new",
  });

  const mutation = useMutation({
    mutationFn: (payload: Partial<z.infer<typeof [Name]Schema>>) =>
      model.upsert(payload),
    onSuccess: () => {
      toast.success("[Name] saved successfully");
    },
  });

  const handleSubmit = (data: z.infer<typeof [Name]Schema>) => {
    mutation.mutate(data);
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-4">
        {id === "new" ? "Create [Name]" : "Edit [Name]"}
      </h1>
      <FormBuilder schema={[Name]Schema} values={data}>
        <FBForm onSubmit={handleSubmit}>
          <FBInput name="name" label="Name" />
          <div className="flex gap-2">
            <FBSubmit handleSubmit={handleSubmit} />
            <FBCancel to="/[name]" />
          </div>
        </FBForm>
      </FormBuilder>
    </div>
  );
}
```

---

## üîç When in Doubt

1. **Search** the codebase for similar implementations
2. **Use** IntelliJ MCP Server for formatting, error checking, and file operations
3. **Use** Shadcn MCP Server for component docs
4. **Search** Brave for latest documentation
5. **Follow** established patterns - consistency is key
6. **Check** this file for patterns and examples

---

## üìù Summary

**This project uses:**

- React 19 + TypeScript + Vite
- Supabase (PostgreSQL + Auth)
- TanStack Query + Zustand
- React Hook Form + Zod
- Shadcn UI (Radix + Tailwind)
- i18next (internationalization)

**Core Systems:**

- BaseModel (data layer)
- FormBuilder (forms)
- DataTableSupabase (tables)

**Golden Rule:**
Build everything with reusability and future use in mind. If you're creating something that could be used elsewhere, make it generic and reusable NOW, not later.
